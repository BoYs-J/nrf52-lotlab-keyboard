# 通讯协议文档

## UART 通讯协议

### 基础格式

CMD DAT ... DAT SUM

- CMD：命令
- DAT：数据
- SUM：前面所有数据和命令的校验和

其中，根据CMD的不同，DAT的长度可能有所变化。若DAT长度为0，则不需要SUM。

主机(CH554)会定期向从机(nRF52810)发送状态数据包，请求从机上传。

### 命令

#### Ping 包与当前状态
```
0b0001 xxxx
       ||||
       |||+--- 上次接收数据是否成功（成功置为1）
       ||+---- 充电状态（充满置为1）
       |+----- 主机状态（与主机连接成功置为1）
       +------ 当前键盘的Protocol
```

无DAT

#### LED 下传
```
0b001x xxxx
     + ++++--- 5Bit的LED状态
```

无DAT

#### HID 通信
```
0b01xx xxxx
    ++ ++++--- 报告数据包的长度，最大为61。DAT的长度是这个长度+1
```
DAT第一位是HID REPORT ID
0: keyboard, 1: mouse, 2: consumer, 3: system, 0x80: nkro keyboard

#### 配置通信
```
0b10xx xxxx 
    || ||||
    ++-++++--- HID 数据包的长度，最大为62，即HID最大长度为62
```
DAT 的长度由上面决定。

#### 配置通信响应
格式同上，具体相应见下。

## 配置通信协议

### 基础格式

CMD LEN DAT[0] ... DAT[N-1]

N 最长不超过60。

> HID 最高支持 64 字节，去掉 Report ID 后，其实也就剩 63 字节了。
> 为什么是60而不是61? 在老的UART通信中，只留了64字节的串口发送指令。去掉包头和后续校验和后，就只剩下62位了。再去掉头部的 CMD 和 LEN，就只剩60了。


对于基于 HID 的配置通信，其长度固定为63（加上ID位则是64）。

```
0x3F CMD  LEN  DAT[0] ... DAT[LEN-1] 0 ... 0
HID  命令  长度        数据部分           补0
```


### 命令类型

命令类型区域如下：

- 0x00-0x0F: 响应代码
- 0x10-0x1F: 预留
- 0x20-0x2F: 获取键盘信息
- 0x30-0x3F: 设置键盘信息
- 0x40-0x7F: 键盘内模块化配置命令
- 0x80-0xEF: 厂商预留命令
- 0xF0-0xFF: 特殊指令，预留

#### 通用响应代码

- 0x00 操作成功
- 0x01 此操作未定义
- 0x02 参数错误
- 0x03 内部错误
- 0x04 写入数据超出限制
- 0x05 UART通信校验错误（请求重发）

#### 0x20 获取键盘信息

请求：
```
SUBINFO[1]: 详细信息（可选，从协议版本 5 起启用）
```

##### 基础信息 (0)

```
VENDOR[2] 生产者ID (0x1071)
PRODUCT[2] 产品ID (0xab60)
HWVER[1] 硬件版本 (3)
PROTOCOL_VER[1] 通信协议版本 (1)
FIRMWARE_VER[4] 固件版本 (0xcb4cde53)
BUILD_DATE[4] 构建时间 (UNIX时间戳)
FUNCTION_TABLE[4] 支持（启用）的功能
```

Function Table:
```
/* 0-7 底层基础功能 */
0: 是否启用BootMagic
1: 是否启用MouseKey
2: 是否启用多媒体和系统键
3: 是否启用NKRO
/* 4-7 留做后续使用 */

/* 8-15 附加功能 */
8: 是否启用Keymap存储
9: 是否使用的是Action Map
10: 是否启用宏
11: 是否启用配置存储

/* 16-31 额外驱动功能 */
16: RGB Light
17: RGB Matrix
18: 旋转编码器
19: 摇杆
...
```

##### 无线传输扩展信息 (1)

```
SERIAL[6] 键盘唯一序列号 (MAC 地址)
MTU[1]    最大分包长度（N）
RFU[1]    预留
```

由于蓝牙HID无法直接获取到 MAC 地址，故需要返回这样的信息；
同时，由于无线传输有MTU限制，所以需要告知配置工具如何分包。

常见的协议MTU取值如下:
- 默认: 56 (59向下对齐到56)
- USB: 60
- BLE: 16 (17 向下对齐到 16)

#### 0x21 获取单个按键键值

请求：
```
LAYER[1] 按键所在层
ROW[1] 按键所在行
COL[1] 按键所在列
```
响应：
```
KEYCODE[2] 对应按键的键值
```

#### 0x22 获取单个Fn的功能

请求：
```
Fn[1] Fn键所属ID
```
响应:
```
KEYCODE[2] 对应按键的键值
```

#### 0x23 获取所有键值

请求:
```
OFFSET[2] 当前请求偏移
```
响应:
```
LEN：表示数据的长度，最多为56；若为0则说明已经响应完毕
DATA[]: 键值数据
```

#### 0x24 获取所有Fn功能

请求:
```
OFFSET[1] 当前请求偏移
```
响应:
```
LEN：表示数据的长度，最多为56；若为0则说明已经响应完毕
DATA[]: 键值数据
```

#### 0x25 获取指定的配置项目的值

请求:
```
INDEX[1] 配置项目的Index
```
响应:
```
DATA[LEN] 指定配置项目的值
```
Index见后面附表

#### 0x27 获取所有宏的值

请求：
```
OFFSET[2] 当前请求的OFFSET
```
响应:
```
DATA[]: 键值数据
```
#### 0x31 设置单个按键键值

请求：
```
LAYER[1] 按键所在层
ROW[1] 按键所在列
COL[1] 按键所在行
KEYCODE[2] 对应按键的键值
```

#### 0x32 设置单个Fn功能

请求：
```
Fn[1] Fn键所属ID
KEYCODE[2] 对应按键的键值
```

#### 0x33 设置所有键值

请求：
```
ID[1] 当前分包的ID
DATA[N] 数据
```

当数据包的长度小于分包长度时，说明发送完毕

#### 0x34 设置所有Fn值

请求：
```
ID[1] 当前分包的ID
DATA[N] 数据
```

当数据包的长度小于分包长度时，说明发送完毕

#### 0x35 设置指定的配置项目的值

请求:
```
ID[1] 配置项目的ID
DAT[LEN-1] 配置项目的值
```

#### 0x37 设置所有宏的值

请求：
```
ID[1] 当前分包的ID
DATA[N] 数据
```

当数据包的长度小于分包长度时，说明发送完毕

#### 0x3D 放弃当前写入的数据

请求：
```
TYPE[1] 写入类型：1：Keymap，2：Fn，4：Config, 8: macro, 0xFF: 所有
```

#### 0x3E 将数据写入存储

请求：
```
TYPE[1] 写入类型：1：Keymap，2：Fn，4：Config, 8: macro, 0xFF: 所有
```

#### 0x3F 重置键盘

请求：
```
TYPE[1] 重置类型：1：Keymap，2：Fn，4：Config, 8: macro, 0xFF: 所有
```

### 0xF0 进入 USB ISP 模式

无请求值，无返回值。执行后直接进入 USB ISP 模式

### 模块自定义处理

#### 0x40 设置/获取当前层

当 LEN = 0 时获取层信息，返回：

```
LAYER[4]
DEFAULT_LAYER[4]
```

当 LEN = 8 时设置层信息，设置值如上

#### 0x41 执行 Action Code

LEN 固定为 2

```
ACTION_CODE[2]
```

执行传入的指定ActionCode

#### 0x42 获取电量信息

LEN 固定为 0，返回：

```
BATT_LEVEL[1]
```

#### 0x43 获取/设置 USB 状态

// T.B.D.

#### 0x44 获取/设置蓝牙状态

// T.B.D.

#### 0x50 获取/设置ESB状态

// T.B.D.


### 配置类型

- 0x10: 长度为2，慢速扫描时间（秒）
- 0x11: 长度为2，自动休眠时间（分）
- 0x12: 长度为2，LED省电模式时间（秒）
